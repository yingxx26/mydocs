什么是MVCC？
多版本并发控制。InnoDB为每行记录添加了一个版本号（系统版本号），每当修改数据时，版本号加一。
在读取事务开始时，系统会给事务一个当前版本号，事务会读取版本号<=当前版本号的数据，这时就算另一
个事务插入一个数据，并立马提交，新插入这条数据的版本号会比读取事务的版本号高，因此读取事务读的数据还是不会变。

数据库并发场景有三种，分别为：
读-读：不存在任何问题，也不需要并发控制
读-写：有线程安全问题，可能会造成事务隔离性问题，可能遇到脏读，幻读，不可重复读（mvcc解决）
写-写：有线程安全问题，可能会存在更新丢失问题，比如第一类更新丢失，第二类更新丢失（Next-Key Lock）

MVCC解决了基于快照读下的幻读，事务 读 取的 行， 要么 是在 事务 开始 前 已经 存在 的，
    要么 是 事务 自身 插入 或者 修 改过 的。并不会读到其他事务的写操作 ！！！
但是MVCC无法解决当前读下的幻读。（forupdate其实就是写写）


Next-Key Lock 解决当前读下的幻读 ：
1：行锁（Record Lock，基于唯一索引）:锁直接加在索引记录上面，锁住的是key。因为唯一索引的特殊性，锁住一个就能确定插入，更新不了
2：间隙锁（Gap Lock，基于普通索引）:锁定索引记录间隙，确保索引记录的间隙不变。
   因为普通索引（比如1,3,5,5,7,9，条件是5）可能重复，所以可能插入3->5和5->7之间，需要锁定3->5和5->7
3：锁表（无索引）

Innodb自动使用间隙锁的条件：
（1）必须在Repeatable Read级别下
（2）检索条件必须有索引（没有索引的话，mysql会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录，此时其他事务不能修改不能删除不能添加）


小结一下咯
总之，MVCC就是因为大牛们，不满意只让数据库采用悲观锁这样性能不佳的形式去解决读-写冲突问题，而提出的解决方案，所以在数据库中，因为有了MVCC，所以我们可以形成两个组合：

MVCC + 悲观锁
MVCC解决读写冲突，悲观锁解决写写冲突
MVCC + 乐观锁
MVCC解决读写冲突，乐观锁解决写写冲突
这种组合的方式就可以最大程度的提高数据库并发性能，并解决读写冲突，和写写冲突导致的问题

mvcc只在事务里面有效，读取快照



