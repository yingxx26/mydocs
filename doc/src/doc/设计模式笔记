Decorated                 装饰器模式    多种折扣方式，扩展折扣
ResponsibilityChain       责任连模式    适合多个ifelse ，并有多个分支可能被执行(即嵌套，看下soar中有没有)  计算积分
Template                  模板模式       选择合同模板，填写信息
Strategy                  策略模式       微信分享
state                     状态模式       订单状态转变

工厂和  策略模式   区别 ： 工厂模式只关注创建对象，策略模式自定义 方法的组合          （共同点，和责任链区别）  处理ifelse 只执行单个分支            
状态模式和责任链模式 ：状态模式 流程已经定义好了，责任链模式不确定

工厂模式和建造者模式  产品之间差异大不适合建造者模式，
桥接模式(Bridge)  action   注入service就是   （正常情况只能一个）。   开发商和中介
外观模式      action service dao  一个service里组合多个dao也是外观模式


适配器模式的意义
将一个接口转变成另一个接口，目的是通过改变接口来达到重复使用的目的。 （继承或实现目标者【】，持有被适配者的引用）

装饰器模式的意义
不改变被装饰对象的接口，而是保持原有的接口，增强原有对象的功能，或改变原有对象的处理方式而增提高性能。（继承或实现被适配者，持有被适配者的引用）

代理模式
（继承或实现被适配者，持有被适配者的引用）
代理模式是在扩展类中直接创建，是采用组合的方式；装饰器模式是采用构造方法传参赋值，是采用聚合的方式。也就是说代理模式是在编译时就已经只要将要操作的对象，而装饰器模式只有到了运行阶段才能确定。另一方面代理模式直接创建对象，对外隐藏了具体的实现，而装饰器模式需要使用者自己去创建具体的实现类。


Observer                  观察者模式    两个接口， 观察者接口，被观察者接口，被观察者持有观察者接口引用
Builder                   建造者模式    构造对象时防止参数过长
访问者模式      action service dao  也是访问模式
Compose         组合模式     树形
XiangyuanModel  享元模式     内存池



-------------------------------------------------------------

适配器是为了 转换匹配，复用，（能不用，就不用）,需要改接口（每次接口不同无法递归）
装饰器 是为了增加功能（对原来对象无感知），顺序可以随意改变，不需要改接口（支持递归组合）
代理模式 编译期已经确定  不改接口

外观模式 外观类和子系统之间没有关系，作用：封装交互，简化调用
工厂：作用：选择实现
迭代器模式 提供统一的遍历，不影响源对象

模板方法：固定算法骨架
责任链：分离职责，动态组合

三层架构：外观模式和工厂模式,桥接模式
